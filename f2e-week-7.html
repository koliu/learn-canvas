<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
</head>

<body>
  <canvas id="draw1">
    這裡有個 canvas，但您的瀏覽器不支援！
  </canvas>

  <script>
    const colors = {
      white: x => x ? `rgba(255, 255, 255, ${x})` : 'rgb(255, 255, 255)',
      red: x => x ? `rgba(231, 70, 93, ${x})` : 'rgb(231, 70, 93)',
      yellow: x => x ? `rgba(245,175, 95, ${x})` : 'rgb(245, 175, 95)',
      blue: x => x ? `rgba(54, 118, 187, ${x})` : 'rgb(54, 118, 187)',
      bgBlue: x => x ? `rgba(0, 29, 46, ${x})` : 'rgb(0, 29, 46)',
      darkGreen: x => x ? `rgba(0, 255, 0, ${x})` : 'rgb(0, 255, 0)',
      transparent: 'rbga(0, 0, 0, 0)'
    };

    const draw1 = document.querySelector("#draw1");
    draw1.width = 720; //window.innerWidth;
    draw1.height = 480; //window.innerHeight;
    const $w = draw1.offsetWidth;
    const $h = draw1.offsetHeight;
    const $cx = $w / 2;
    const $cy = $h / 2;
    const $divides = 3;
    /* base width */
    const $bw = $w / $divides;
    /* base height */
    const $bh = $h / $divides;
    const $angle360 = Math.PI * 2 / 180;
    console.log(
      `$w=${$w}`,
      `$h=${$h}`,
      `$bw=${$bw}`,
      `$bh=${$bh}`,
      `$angle360=${$angle360}`
    );
    const fontFamily = "Roboto,Arial,微軟正黑體";
    let tempX, tempY;

    const ComponentBattery = class ComponentBattery {
      constructor(unitX = 10, unitY = 10) {
        this.unitX = unitX;
        this.unitY = unitY;
      }

      head() {
        return new Path2D(`M${this.unitX} 0 h ${this.unitX * 2} v ${this.unitY} h ${- this.unitX * 2} Z`);
      };

      body() {
        return new Path2D(`M0 0 h ${this.unitX * 4} v ${this.unitY * 6} h ${- this.unitX * 4} Z`);
      };

      foot() {
        return new Path2D(`M0 0 h ${this.unitX * 4} v ${this.unitY} h ${- this.unitX * 4} Z`);
      }
      bolt() {
        const path = new Path2D();
        path.moveTo(this.unitX * 0, this.unitY * 0);
        path.lineTo(this.unitX * 1.5, this.unitY * 0);
        path.lineTo(this.unitX * -1, this.unitY * 2.5);
        path.closePath();
        return path;
      }
    };

    const icons = {
      battery: {
        draw: function (ctx, x = 0, y = 0, scaleX = 1, scaleY = 1, energy = 100) {
          ctx.translate(x, y);
          ctx.scale(scaleX, scaleY);
          ctx.save();

          const unit = 10;
          const componentBattery = new ComponentBattery(unit, unit);


          // head
          ctx.fillStyle = colors.white();
          ctx.fill(componentBattery.head());
          ctx.restore();

          // body
          ctx.save();
          ctx.fillStyle = colors.yellow();
          ctx.strokeStyle = colors.yellow();
          ctx.translate(0, unit);
          ctx.fill(componentBattery.body());
          ctx.stroke(componentBattery.body());
          if (energy < 100) {
            ctx.fillStyle = colors.bgBlue();
            ctx.scale(1, (100 - energy) / 100)
            ctx.fill(componentBattery.body());
          }
          ctx.restore();

          // bottom
          ctx.save();
          ctx.fillStyle = colors.yellow();
          ctx.strokeStyle = colors.yellow();
          ctx.translate(0, unit * 7.5);
          ctx.fill(componentBattery.foot());
          ctx.stroke(componentBattery.foot());
          ctx.restore();

          // bolt
          ctx.save();
          ctx.fillStyle = colors.white();
          ctx.translate(unit * 2, unit * 3.75);
          ctx.fill(componentBattery.bolt(), "nonzero");
          ctx.translate(0, unit * 0.5);
          ctx.rotate(Math.PI);
          ctx.fill(componentBattery.bolt(), "nonzero");
          ctx.restore();

        }
      }
    }

    const ctx = draw1.getContext ? draw1.getContext("2d") : undefined;

    const lineX = new Path2D();
    lineX.moveTo(0, 0);
    lineX.lineTo($w, 0);
    lineX.closePath();

    const lineY = new Path2D();
    lineY.moveTo(0, 0);
    lineY.lineTo(0, $h);
    lineY.closePath();

    const circle = new Path2D();
    circle.arc(0, 0, $h / 2, 0, $angle360, true);

    ctx.save();

    ctx.strokeStyle = colors.darkGreen(0.3);
    // draw grid lines
    Array.from(Array($divides - 1).keys()).forEach(i => {
      const tempI = i + 1;

      ctx.translate($bw * tempI, 0);
      ctx.stroke(lineY);
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.translate(0, $bh * tempI);
      ctx.stroke(lineX);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    })

    let tempScale = 0.01;
    // draw origin
    ctx.translate($cx, $cy);
    ctx.scale(tempScale, tempScale);
    ctx.fillStyle = colors.darkGreen(0.3);
    ctx.fill(circle);
    ctx.setTransform(1, 0, 0, 1, $cx, $cy);

    // draw outer circle
    tempScale = 0.44 + 1 / 3;
    ctx.scale(tempScale, tempScale);
    ctx.strokeStyle = colors.white(0.3);
    ctx.stroke(circle);
    ctx.setTransform(1, 0, 0, 1, $cx, $cy);

    // draw inner circle
    tempScale = 0.55;
    ctx.scale(tempScale, tempScale);
    ctx.strokeStyle = colors.white();
    ctx.lineWidth = 3;
    ctx.stroke(circle);
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // top-right yellow circle
    ctx.beginPath();
    ctx.arc($bw * 2.5, $bh / 3 * 1.8, 0.2 * $bh, 0, Math.PI * 2 / 180, true);
    ctx.fillStyle = colors.yellow();
    ctx.fill();

    // bottom triangle
    tempX = $bw * 2.2;
    tempY = $bh * 2.1;
    ctx.beginPath();
    ctx.moveTo(tempX, tempY);
    ctx.lineTo(tempX - 45, tempY + 70);
    ctx.lineTo(tempX + 35, tempY + 75);
    ctx.fillStyle = colors.blue();
    ctx.fill();

    // top-left hexagon
    tempX = $bw * 0.17;
    tempY = $bh * 0.8;
    ctx.beginPath();
    ctx.moveTo(tempX - 5, tempY + 5);
    ctx.lineTo(tempX + 35, tempY - 10);
    ctx.lineTo(tempX + 70, tempY + 5);
    ctx.lineTo(tempX + 75, tempY + 30);
    ctx.lineTo(tempX + 55, tempY + 60);
    ctx.lineTo(tempX + 10, tempY + 45);
    ctx.fillStyle = colors.red();
    ctx.fill();

    // draw text
    ctx.fillStyle = colors.white();
    tempX = $bw * 0.13;
    tempY = $bh * 2.5;
    ctx.font = `14px ${fontFamily}`;
    ctx.fillText('你身負著運送能量電池的任務', tempX, tempY);
    ctx.fillText('卻遭到幾何星人的埋伏', tempX, tempY + 20);
    ctx.fillText('請協助從他們的手中奪回能量電池', tempX, tempY + 40);

    tempScale = 10;
    ctx.font = `70px ${fontFamily}`;
    ctx.fillText('R', $cx - 15, $cy - 20);

    ctx.font = `20px ${fontFamily}`;
    ctx.fillText('Radio Defence', $cx - 60, $cy + 10);

    ctx.font = `15px ${fontFamily}`;
    ctx.fillText('Start Game', $cx - 32, $cy + 62);

    ctx.moveTo($cx - 50, $cy - 50);

    icons.battery.draw(ctx, $cx - 40, $cy - 59, 0.5, 0.45, 30);
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Roboto', sans-serif;
    }

    #draw1 {
      background-color: #001D2E;
    }
  </style>
</body>

</html>
